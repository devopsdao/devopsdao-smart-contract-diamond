// const { ethers } = require("hardhat");
const Arweave = require('arweave')
const fs = require('fs/promises')
const path = require('node:path');


// async function main(){

//     await mintNFTs();

// }
let contractAddresses;

(async() => {
  const contractAddressesJson = await fs.readFile(path.join(__dirname, `../abi/addresses.json`));
  if(typeof contractAddressesJson !== 'undefined'){
    contractAddresses = JSON.parse(contractAddressesJson);
  }
  else{
    console.log(`contract addresses file not found at ../abi/addresses.json`)
}
})()


function fromAscii(str, padding) {
  var hex = '0x';
  for (var i = 0; i < str.length; i++) {
      var code = str.charCodeAt(i);
      var n = code.toString(16);
      hex += n.length < 2 ? '0' + n : n;
  }
  return hex + '0'.repeat(padding*2 - hex.length + 2);
};

let nonces = {};

async function getNonce(address, incremental) {
  if(typeof nonces[address] == 'undefined'){
    nonces[address] = await ethers.provider.getTransactionCount(address);
  }
  let currentNonce = nonces[address];
  if(incremental == true){
    nonces[address] = currentNonce + 1;
  }
  else{
    nonces[address] = await ethers.provider.getTransactionCount(address);
  }
  console.log(`current nonce: ${currentNonce}`)
  return currentNonce;
}

task("getWalletAddress", "Get the wallet address for a given account ID")
  .addParam("account", "The account ID")
  .setAction(async (taskArgs, hre) => {
    const signers = await hre.ethers.getSigners();
    const walletAddress = await signers[taskArgs.account].getAddress();
    console.log(walletAddress);
  });


task(
  "devCreateTask",
  "create a dodao task")
  .addParam("account", "account id")
  .addParam("type", "task type")
  .addParam("title", "task title")
  .addParam("description", "task description")
  .addParam("tags", "task tags")
  .addParam("tokens", "task reward symbols(DEV, aUSDC, NFT tokens)")
  .addParam("amounts", "symbol amounts")
  .setAction(
  async function (taskArguments, hre, runSuper) {
    signers = await ethers.getSigners();
    const diamondAddress = contractAddresses.contracts[hre.network.config.chainId]['Diamond'];
    taskCreateFacet = await ethers.getContractAt('TaskCreateFacet', diamondAddress)


    let account = taskArguments.account

    let tags = []

    if(taskArguments.tags.indexOf(',') != -1){
      tags = taskArguments.tags.split(',')
    }
    else{
      tags.push(taskArguments.tags)
    }

    let tokens = []
    if(taskArguments.tokens.indexOf(',') != -1){
      tokens = taskArguments.tokens.split(',')
    }
    else{
      tokens.push(taskArguments.tokens)
    }

    let amounts = []

    if(taskArguments.amounts.indexOf(',') != -1){
      amounts = taskArguments.amounts.split(',')
    }
    else{
      amounts.push(taskArguments.amounts)
    }

    const { customAlphabet } = require('nanoid');

    const nanoId = customAlphabet('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz-', 12)();

    if(tokens.length === amounts.length){
      const taskData = {
        nanoId: nanoId,
        taskType: taskArguments.type,
        title: taskArguments.title,
        description: taskArguments.description,
        repository: "",
        tags: tags,
        tokenContracts: ["0x0000000000000000000000000000000000000000"],
        tokenIds: [[0]],
        tokenAmounts: [[0]],
      }


      console.log(taskData)


      console.log(`using Diamond: ${diamondAddress} and ${signers[account].address} account`)



      let feeData = await ethers.provider.getFeeData();
      console.log(feeData)
      let gasMultiplier = 1;
      let txSuccess = false;
      let event;
      while(!txSuccess){
        try{
          //your logic
          console.log(`sending tx`)
          tx = await taskCreateFacet.connect(signers[account]).createTaskContract(signers[account].address, taskData,
            {nonce: await getNonce(signers[account].address, false), type: 2, maxFeePerGas: feeData.maxFeePerGas+gasMultiplier, maxPriorityFeePerGas: feeData.maxPriorityFeePerGas+gasMultiplier  })
          const receipt = await tx.wait()
          event = receipt.events[0]
          txSuccess = true;
        }catch(error){
          console.log(error);
          gasMultiplier = gasMultiplier+1;
          console.log(`retrying with ${gasMultiplier} gasMultiplier`);
          continue;
        }
      }

      
      console.log(`created new task contract ${event.address}`)
    }
    else{
      console.log('--symbols and --amounts argument count must match')
    }

  }
);


task(
  "devTaskParticipate",
  "participate in a dodao task"
)
.addParam("account", "account id")
.addParam("taskcontract", "task contract")
.addParam("message", "message text")
.setAction(
  async function (taskArguments, hre, runSuper) {
      signers = await ethers.getSigners();
      const taskContract = await ethers.getContractAt('TaskContract', taskArguments.taskcontract);
      tx = await taskContract.connect(signers[taskArguments.account]).taskParticipate(signers[taskArguments.account].address, taskArguments.message, 0);
      const receipt = await tx.wait();
      const event = receipt.events[0];
      const { contractAdr, message, timestamp } = event.args;
      console.log(`updated task contract ${contractAdr}`);
  }
);


task(
  "devTaskAuditParticipate",
  "participate in a dodao task audit"
)
.addParam("account", "account id")
.addParam("taskContract", "task contract")
.addParam("messageText", "message text")
.setAction(
  async function (taskArguments, hre, runSuper) {
      signers = await ethers.getSigners();
      const taskContract = await ethers.getContractAt('TaskContract', taskArguments.taskContract);
      tx = await taskContract.connect(signers[taskArguments.account]).taskAuditParticipate(signers[taskArguments.account].address, taskArguments.messageText, 0);
      const receipt = await tx.wait();
      const event = receipt.events[0];
      const { contractAdr, message, timestamp } = event.args;
      console.log(`updated task contract ${contractAdr}`);
  }
);


const taskStateNew = 'new'
const taskStateAgreed = 'agreed'
const taskStateProgress = 'progress'
const taskStateReview = 'review'
const taskStateAudit = 'audit'
const taskStateCompleted = 'completed'
const taskStateCanceled = 'canceled'
const taskAuditStatePerforming = 'performing'
const taskAuditStateFinished = 'finished'
taskStateAuditDecision = 'canceled'
taskStateAuditDecision = 'completed'


task(
  "devTaskStateChange",
  "change dodao task state"
)
.addParam("account", "account id")
.addParam("taskContract", "task contract")
.addParam("taskState", "task state, can be: new, agreed, review, audit, performing or finished")
.addParam("messageText", "message text")
.addOptionalParam("participant", "NFT names")
.setAction(
  async function (taskArguments, hre, runSuper) {
      signers = await ethers.getSigners();
      if (typeof taskArguments.participant != 'undefined') {
          participant = taskArguments.participant;
      } else {
          participant = '0x0000000000000000000000000000000000000000';
      }

      const taskContract = await ethers.getContractAt('TaskContract', taskArguments.taskContract);

      if (taskArguments.taskState === taskStateAgreed || taskArguments.taskState === taskStateProgress || taskArguments.taskState === taskStateReview || taskArguments.taskState === taskStateAudit) {
          tx = await taskContract.connect(signers[taskArguments.account]).taskStateChange(signers[taskArguments.account].address, participant, taskArguments.taskState, taskArguments.messageText, 0, 0);
          const receipt = await tx.wait();
          const event = receipt.events[0];
          const { contractAdr, message, timestamp } = event.args;
          console.log(`updated task contract ${contractAdr}`);
      } else {
          console.log('Invalid task state provided');
      }
  }
);

task(
  "devTaskAuditDecision",
  "take dodao task audit decision"
)
.addParam("account", "account id")
.addParam("taskContract", "task contract")
.addParam("favour", "task audit decision can be taken in favour of customer or performer")
.addParam("messageText", "message text")
.addParam("rating", "rating of the performer")
.setAction(
  async function (taskArguments, hre, runSuper) {
      signers = await ethers.getSigners();
      if (taskArguments.favour !== 'customer' && taskArguments.favour !== 'performer') {
          console.log(`task audit can be settled either in customer or performer favour`);
      } else {
          let rating = 0;
          if (typeof taskArguments.rating !== 'undefined') {
              rating = taskArguments.rating;
          }

          const taskContract = await ethers.getContractAt('TaskContract', taskArguments.taskContract);
          tx = await taskContract.connect(signers[taskArguments.account]).taskAuditDecision(signers[taskArguments.account].address, taskArguments.favour, taskArguments.messageText, 0, rating);
          const receipt = await tx.wait();
          const event = receipt.events[0];
          const { contractAdr, message, timestamp } = event.args;
          console.log(`updated task contract ${contractAdr}`);
      }
  }
);


task("devGetTaskContractsByState", "Get task contracts by state")
  .addParam("taskState", "The task state to filter by")
  .setAction(async (taskArgs, hre) => {
    const diamondAddress = contractAddresses.contracts[hre.network.config.chainId]['Diamond'];
    console.log(`Calling ${diamondAddress}`);

    const taskContract = await ethers.getContractAt('TaskDataFacet', diamondAddress);

    const taskContractsByState = await taskContract.getTaskContractsByState(taskArgs.taskState);
    console.log(taskContractsByState);
  });

task(
  "devGetTaskContractsCustomer",
  "get task contracts for a customer")
  .addParam("address", "customer address")
  .setAction(
  async function (taskArguments, hre, runSuper) {
    const diamondAddress = contractAddresses.contracts[hre.network.config.chainId]['Diamond'];
    console.log(`calling ${diamondAddress}`)

    // signers = await ethers.getSigners();

    const taskContract = await ethers.getContractAt('TaskDataFacet', diamondAddress);
    call = await taskContract.getTaskContractsCustomer(taskArguments.address);
    console.log(call)
  }
);

task("devGetTaskContractsPerformer", "Get task contracts for a given performer")
  .addParam("performerAddress", "The address of the performer")
  .setAction(async (taskArgs, hre) => {
    const diamondAddress = contractAddresses.contracts[hre.network.config.chainId]['Diamond'];
    console.log(`Calling ${diamondAddress}`);

    const taskContract = await ethers.getContractAt('TaskDataFacet', diamondAddress);

    const performerTaskContracts = await taskContract.getTaskContractsPerformer(taskArgs.performerAddress);
    console.log(performerTaskContracts);
  });

task(
  "devGetTasksData",
  "get task data for a list of task contracts"
)
.addParam("taskContracts", "array of task contract addresses")
.setAction(
  async function (taskArguments, hre, runSuper) {
      const diamondAddress = contractAddresses.contracts[hre.network.config.chainId]['Diamond'];
      console.log(`calling ${diamondAddress}`);

      const taskContract = await ethers.getContractAt('TaskDataFacet', diamondAddress);

      const tasksData = await taskContract.getTasksData(taskArguments.taskContracts);
      console.log(tasksData);
  }
);


task(
  "devTokenGetBalanceOf",
  "get token balance")
  .addParam("address", "customer address")
  .addParam("id", "token ID")
  .setAction(
  async function (taskArguments, hre, runSuper) {
    const diamondAddress = contractAddresses.contracts[hre.network.config.chainId]['Diamond'];
    console.log(`calling ${diamondAddress}`)

    // signers = await ethers.getSigners();

    const taskContract = await ethers.getContractAt('TokenFacet', diamondAddress);
    call = await taskContract.balanceOf(taskArguments.address, taskArguments.id);
    console.log(call)
    console.log(call.length)
  }
);

task(
  "devTransferNFT",
  "send NFT")
  .addParam("address", "destination address")
  .addParam("id", "token id")
  .addParam("amount", "amount")
  .setAction(
  async function (taskArguments, hre, runSuper) {
    const diamondAddress = contractAddresses.contracts[hre.network.config.chainId]['Diamond'];
    console.log(`calling ${diamondAddress}`)

    signers = await ethers.getSigners();
    const tokenFacet = await ethers.getContractAt('TokenFacet', diamondAddress);
    call = await tokenFacet.connect(signers[1]).safeTransferFrom(signers[1].address, taskArguments.address, taskArguments.id, taskArguments.amount, fromAscii(''));
    console.log(call)
    console.log(call.length)
  }
);


// (async() => {
//     await main()
//   })()